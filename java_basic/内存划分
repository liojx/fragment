1. JVM 分大类
    --> Class Loader (类加载器)  .java 文件通过编译器编译成.class文件，然后由类加载器加载到内存里面来
    --> Execution Engine (执行引擎)
    --> Runtime data Area (运行时数据区)
2. Runtime data Area 分类
    --> Java 栈区 (VM Stack)
    --> 堆区 (Heap)
    --> 本地方法栈 (Native Method Stack)
    --> 方法区 (Method Area)
    --> 程序计数器 (Program Counter Register)
    
    2.1 程序计数器
     程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指
     CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到
     当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，
     如此循环，直至执行完所有的指令。
     
     虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻
     辑上是等同的，也就是说是用来指示 执行哪条指令的。

     由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每
     个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行
     次序。因此，可以这么说，程序计数器是每个线程所私有的。

     在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的
     值是undefined。

     由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。
   2.2 JAVA 栈
    
