https://www.cnblogs.com/dolphin0520/p/3920373.html 
这篇博客园的文章为了把volatile讲透彻，把CPU缓存、内存模型等都捋顺了一遍，看后甚是大悦。
吸收归纳一下：
  1.内存模型
  CPU运行的速度很快，内存很慢，内存数据的存取直接影响到CPU的运行效率，从而在CPU上加了L1、L2、L3的高速缓存。看一个例子：i = i + 1;
  这里的操作是，CPU先去从缓存读取i的值，再+1，再赋新值。单线程运行出来的结果是没毛病的。倘若多线程运行就会出现问题，因为，每个线程都会把
  相应的操作丢到自己的高速缓存里面，倘若上面的例子i的初值是0，A线程从主内存取得i并操作后 i的值变为1，而A线程并未刷新新值到主内存时，
  B线程也从主存中获取i的值，i值也为0，最后B线程操作后i的值仍是1，此时就达不到我们的预期。
  
  为了解决这个问题，大佬们最开始试图从硬件着手，锁总线，锁总线后，线程A 要操作完毕后，后面的其他线程，或者更多的CPU才能够使用，这样大大影响
  工作效率，这种因噎废食的做法肯定是不可取的。第二种是缓存一致性协议：思想是，如果CPU发现即将操作的变量是共享变量时，每个CPU都存一个相同的
  变量副本，当操作的变量变化时，通知其他CPU将该变量的缓存行置为无效，其他CPU去获取该变量发现时缓存无效时，就又从主内存中重新读取。
  
  2.并发的三个原则：原子性、可见性、有序性
    原子性：本意是原子是不可分割的整体，即一个操作或一系列操作要么全部成功，要么全部失败。比如经典的转账例子，要么就转账成功，来上账，去下账都成功
           要去就转账失败，来 未下账，去也未上账。
    可见性：可见性即是上面说的共享变量的情况，共享变量的值被更改后，不是只停留在当前线程的缓存中，而是所有的线程都可以立即看到。
    有序性：这里面又有一个概念，CPU为了更有效的提升性能，往往会对指令的先后顺序进行优化，从而达到最快的执行效率，但会保证结果的准确性，前提是
           单线程能够保证正确性。如何保证结果准确性呢？CPU的指令优化是刨开依赖性做的，比如说下面的例子：
           i = 120; // 1
           y = i * 3; // 2
           boolean b = true; // 3
           这里面，如果是CPU做指令重排序的话，是不可能把 2 放在 1前面执行的，因为2依赖1， 而3是有可能放在1 和 2前面来执行，因为结果是有保证的。
           指令重排序只是针对单个CPU执行单个线程可以保证数据准确性的，倘若发生多线程的情况，就会出现错误，比如下面的例子：
           
           // 线程1
           context = initContext() ; // 1
           inited = true ; //2 
           
           //线程2
           while(!inited){
              sleep();
           }
           doSomething(context);
           
           // 线程1 若发生指令重排序的话，2和1是没有依赖的，可能2放在前面执行，当2放在前面执行时，把inited刷新到主存去的话，紧接着线程2取到
           inited的值是true，那么还未实例化的context被使用，就会程序出错。
   3.Java 本身是如何保证原子性、可见性、有序性的呢？
      i). 原子性
        Java 只对原子操作保证一致性。也就是只对简单的读取或者赋值保证一致性，也就说两个操作以上，有可能做了第一个操作，第二个操作被打断
        不能一次完成的话，就不能保证一致性。比如下面的例子：
           x = 1; // 1
           y = x; // 2
           x ++; //3 
           x = x  + 1 //4
        这4条语句，仅仅第一条是原子性的，因为直接把1 赋值给x 的。
        第二条： 第一个操作是取 x 的值，有可能其他线程对x进行操作，然后当前线程再来 把x 赋值给y,所以，非原子性
        第三条： 第一个操作是取 x 的值，第二个操作是 x + 1,第三个操作是 把x + 1后的新值赋值给x,所以，非原子性
        第四条： 和第三条一样，非原子性。
        
       ii). 可见性
        Java中用volatile 来保证数据可见性，会阻止指令重排序，但是不能够保证原子性。
        
       iii). 有序性
        Java用synchronize 和Lock来保证程序的有序性，而Java 内存模型也有自己的有序性原则：happens-before(先行发生原则)
        程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
        锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
        volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
        传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
        线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
        线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
        线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的
                    返回值手段检测到线程已经终止执行
        对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
        
     4.volatile的机制
        它能够保证可见性
        它能够禁止指令重排序，保证有序性
        不能够保证原子性
     5.volatile 的使用场景
     
      1) 对变量的写操作不依赖于当前值
　　  2) 该变量没有包含在具有其他变量的不变式中
　　  实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。
　　  事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。
      
        
