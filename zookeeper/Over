1.ZooKeeper:为分布式应用提供的分布式协调服务
ZooKeeper是一个面向分布式应用的分布式开源协调服务。它
公开一组简单的原语，分布式应用程序可以在此基础上构建这些原语来实现
用于同步、配置维护和组和的高级服务
命名。它被设计为易于编程，并使用了以
熟悉文件系统的目录树结构。它在Java中运行，并且对这两个Java都有绑定
和C。
众所周知，协调服务很难得到正确的处理。他们特别容易出错
例如竞态条件和死锁。动物园管理员背后的动机是解压
分布式应用程序实现协调服务的职责
从零开始。
1.1设计目标
饲养员很简单。ZooKeeper允许分布式进程相互协调
通过类似于标准文件系统的共享层次命名空间。
名称空间由数据寄存器(ZooKeeper术语称为znodes)和这些寄存器组成
类似于文件和目录。与典型的存储文件系统不同，
ZooKeeper数据保存在内存中，这意味着ZooKeeper可以获得高吞吐量
和低延迟数。
ZooKeeper的实现注重高性能、高可用性、
严格有序的访问。ZooKeeper的性能方面意味着它可以大规模使用，
分布式系统。可靠性方面防止它成为一个单点故障。的
严格的排序意味着复杂的同步原语可以在
客户端。
管理员是复制。就像它协调的分布式进程一样，ZooKeeper本身也是
打算在一组称为集成的主机上复制。

组成动物园管理员服务的服务器必须相互了解。他们
维护内存中的状态映像，以及a中的事务日志和快照
持久化存储。只要大部分服务器可用，ZooKeeper服务就会可用
可用。
客户端连接到一个ZooKeeper服务器。客户端通过维护TCP连接
它发送请求，获取响应，获取事件，并发送心跳。如果TCP
连接到服务器中断，客户端将连接到另一个服务器。
管理员是有序的。ZooKeeper会在每次更新时用一个数字来表示订单
所有动物园管理员的交易。后续操作可以使用该命令实现更高级别
抽象，例如同步原语。
动物园管理员很快。它在“读主导”工作负载中特别快。动物园管理员
应用程序运行在数千台机器上，在读取次数较多的地方表现最好
比写常见，比率约为10:1。
1.2数据模型和分层命名空间
ZooKeeper提供的名称空间与标准文件系统非常相似。一个名字
是由斜线(/)分隔的路径元素序列。动物园管理员名字里的每个节点
空间由路径标识。
动物园管理员的等级名称空间
1.3节点和短暂节点
与标准文件系统不同，ZooKeeper名称空间中的每个节点都可以拥有数据
和孩子们一样。这就像拥有一个文件系统，它也允许文件
是一个目录。(ZooKeeper用于存储协调数据:状态信息，
配置、位置信息等，所以存储在每个节点上的数据通常很小
字节到千字节范围。)我们使用术语znode来说明我们在讨论什么
管理员数据节点。
Znodes维护一个stat结构，其中包含用于数据更改的版本号ACL
更改和时间戳，以允许缓存验证和协调更新。每次
znode的数据改变，版本号增加。例如，当客户端检索时
它还接收数据的版本。
存储在名称空间中的每个znode上的数据是按原子方式读写的。读取所有
与znode和write关联的数据字节替换所有数据。每个节点都有访问权
控制列表(ACL)，它限制谁可以做什么。
ZooKeeper也有短暂节点的概念。这些znode只要
创建znode的会话是活动的。会话结束时，删除znode。
当您希望实现[tbd]时，临时节点非常有用。
1.4条件更新和监视
ZooKeeper支持手表的概念。客户端可以在znodes上设置一个手表。一块手表
将在znode更改时触发并删除。当一个手表被触发时，客户端
接收一个包，该包表示znode已更改。如果连接客户端
如果动物园管理员的一个服务器坏了，客户端将收到一个本地通知。这些
可用于[tbd]。
1.5保证
动物园管理员非常快，也非常简单。因为它的目标是成为
构造比较复杂的服务，如同步，它提供了一组
担保。这些都是:
•顺序一致性——来自客户端的更新将按照它们原来的顺序应用
发送。
•原子性——更新成功或失败。没有部分结果。
•单个系统映像——客户端将看到服务的相同视图，而不管
它所连接的服务器。
•可靠性——一旦应用了更新，它将从那时一直持续到
客户端重写更新。
•及时性——保证客户对系统的视图在a中是最新的
特定的时间。
欲知更多有关这些及如何使用的资料，请参阅[待定]
1.6简单的API
ZooKeeper的设计目标之一就是提供一个非常简单的编程接口。作为一个
结果，它只支持以下操作:
create
creates a node at a location in the tree
delete
deletes a node
exists
tests if a node exists at a location
get data
reads the data from a node
set data
writes data to a node
get children
retrieves a list of children of a node
sync
waits for data to be propagated

以便更深入地讨论这些问题，以及如何使用它们来实现更高级别
有关运作，请参阅[待定]
1.7实现
ZooKeeper组件显示了ZooKeeper服务的高级组件。与
请求处理器(组成ZooKeeper的每个服务器)的异常
服务复制每个组件的自己的副本。

复制的数据库是内存中的数据库，其中包含整个数据树。更新
为了可恢复性而记录到磁盘，并且写操作在应用到磁盘之前被序列化到磁盘
内存数据库。
每个ZooKeeper服务器都为客户端提供服务。客户端连接到一个服务器提交
irequests。读取请求从每个服务器数据库的本地副本提供服务。请求
改变服务状态的写请求由协议协议处理。
作为协议协议的一部分，所有来自客户机的写请求都被转发到单个客户机
服务器，呼叫领导。其余的动物园管理员服务器(称为追随者)接收信息
来自领导的信息建议，并同意信息传递。消息传递层
负责在失败时更换领导，并使追随者与领导保持同步。
ZooKeeper使用自定义原子消息传递协议。由于消息传递层是原子的，
动物园管理员可以保证当地的复制品不会出现分歧。当领导收到a
写请求，它计算系统的状态是什么时候写的应用和
将此转换为捕获此新状态的事务。
1.8使用
ZooKeeper的编程接口非常简单。然而，有了它，你可以
实现更高阶的操作，例如同步原语、组成员关系、
所有权等等。一些分布式应用程序使用它来:[待定:从白色添加用途]
论文和视频演示。]有关详情，请参阅[待定]
1.9性能
《动物园管理员》被设计得非常出色。但真的是这样吗?动物园管理员的检查结果
雅虎的开发团队!研究表明确实如此。(见饲养员吞吐量
由于读写比率不同。)在应用程序中，它的性能尤其高
读操作多于写操作，因为写操作涉及同步所有服务器的状态。(读
对于协调服务来说，写的数量超过写的数量通常是一种情况。

随着读写比的变化，ZooKeeper的吞吐量为的吞吐量图
ZooKeeper版本3.2运行在两台2Ghz Xeon和两台SATA 15K RPM的服务器上
驱动器。其中一个驱动器被用作专用的动物园管理员日志记录设备。快照是这样写的
到操作系统驱动器。写请求是1K次写，读是1K次读。“服务器”
指示ZooKeeper集成的大小、组成服务的服务器数量。
大约30台其他服务器被用来模拟客户机。动物园管理员合奏
配置为不允许从客户端连接。
注意:
在3.2版本中，r/w性能比前3.1版本提高了约2倍。
基准测试也表明它是可靠的。可靠性在错误的存在显示
部署如何响应各种失败。在图中标记的事件是
后:
1. 失败和追随者的恢复
2. 失败和恢复不同的追随者
3.领导者的失败
4. 失败和恢复两个跟随者
5. 另一个领导者的失败

1.10可靠性
为了在注入故障时显示系统随时间推移的行为，我们运行了一个动物园管理员
服务由7台机器组成。我们运行了与以前相同的饱和度基准测试，但是这个
我们把写的百分比保持在30%不变，这是一个保守的比例
预期的工作负载。
误差存在时的可靠性
这是一些重要的观察从这个图表。首先，如果跟随者失败并恢复
很快，ZooKeeper就可以在失败的情况下保持高吞吐量。但也许
更重要的是，领导人选举算法允许系统恢复足够快
以防止吞吐量大幅下降。在我们的观察中，动物园管理员采取了
不到200毫秒就能选出新的领导人。第三，随着追随者的恢复，动物园管理员能够提高
一旦它们开始处理请求，吞吐量将再次提高。
1.11动物园管理员项目
ZooKeeper已经成功应用于许多工业领域。它在雅虎使用
作为雅虎的协调和故障恢复服务!消息代理，这是一个
动物园管理员
版权©Apache软件基金会。保留所有权利。9页
高度可伸缩的发布-订阅系统，管理用于复制和
数据交付。它被Yahoo!爬虫，它也在那里管理
故障恢复。一些雅虎!广告系统也使用ZooKeeper来实现
可靠的服务。
我们鼓励所有用户和开发人员加入这个社区并贡献他们的专业知识。
有关更多信息，请参见Apache上的Zookeeper项目。
